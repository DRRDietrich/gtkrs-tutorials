<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Michael's GTK Rust Tutorial — 2021 Edition</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about-gtk.html"><strong aria-hidden="true">1.</strong> About GTK</a></li><li class="chapter-item expanded "><a href="02-getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="03-event-driven.html"><strong aria-hidden="true">3.</strong> Event-Driven Approach</a></li><li class="chapter-item expanded "><a href="04-window.html"><strong aria-hidden="true">4.</strong> Creating a Window with a Button</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Michael's GTK Rust Tutorial — 2021 Edition</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-gtk"><a class="header" href="#about-gtk">About GTK</a></h1>
<blockquote>
<p><strong>WARNING</strong>: This tutorial assumes familiarity with Rust.</p>
</blockquote>
<p>Before we begin, it is important to know a few things about GTK itself. The architecture that GTK is built upon strongly influences the way that we will interact with it. Yet I won't dive too deeply into the details, because we only need cover what's most important for us as a consumer of the API in Rust.</p>
<h2 id="gtk-heavily-uses-glib"><a class="header" href="#gtk-heavily-uses-glib">GTK heavily uses GLib</a></h2>
<p>GTK is a GUI toolkit built strongly around GLib and it's GLib Object System — which we'll simply call GObject. GLib is essentially a high level cross-platform standard library for C. The GObject portion of GLib enables programming with an object-oriented paradigm.</p>
<p>GTK uses GLib both for it's object system and asynchronous runtime. Every widget type is a GObject class, and most widget classes inherit multiple layers of GTK widget classes. Widgets schedule tasks for concurrent execution on the default async executor (<code>gtk::MainContext::default()</code>), and register signals that react to various property and state changes.</p>
<p>Luckily for us, the behaviors of every class implemented in GTK can be conveniently represented as a trait in Rust. Even better, GTK fully supports a feature known as &quot;GObject Introspection&quot;, which is a convenient way of automatically generating quality bindings in other programming languages. This allowed GTK to have first class bindings in a short amount of time.</p>
<h2 id="initialized-widgets-are-objects"><a class="header" href="#initialized-widgets-are-objects">Initialized widgets are objects</a></h2>
<p>As for what that means to us, <code>GObjects</code> are heap-allocated with interior mutability. Behaviorally, they operate very similarly to how you would expect to work with a <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> type in Rust. You'll never be required to have unique ownership or a mutable reference to modify a widget, as a result.</p>
<p>When you clone a GObject, you are creating a new strong reference to the object. When all strong references have been dropped, the destructor for that object is run. However, cyclic references are possible with strong references which can prevent the strong count from ever reaching 0, so there's an option to downgrade them into a weak reference. We'll be designing our software in a way that mitigates the need for this though.</p>
<h2 id="widgets-have-inheritance"><a class="header" href="#widgets-have-inheritance">Widgets have inheritance</a></h2>
<p>Being built in an object-oriented fashion, widgets are built by inheriting other widgets. So a <code>gtk::Box</code> is a subclass of <code>gtk::Container</code>, which is also a subclass of <code>gtk::Widget</code>; and therefore we can downgrade a <code>gtk::Box</code> into a <code>gtk::Container</code>, and we can further downgrade that into a <code>gtk::Widget</code>.</p>
<p>There may be times when an API hands you a <code>gtk::Widget</code>, and you'll need to upgrade that widget into a more specific type of widget if you want to access methods from that widget's class.</p>
<p>Or there may also be times when you just want to simplify your code and downgrade a widget into a <code>gtk::Widget</code> because you're passing it onto something that takes any kind of widget as an input.</p>
<h2 id="widget-classes-are-traits"><a class="header" href="#widget-classes-are-traits">Widget classes are traits</a></h2>
<p>In the GTK-rs implementation, methods from classes are conveniently stored in traits. The <code>gtk::Widget</code>, <code>gtk::Container</code>, and <code>gtk::Box</code> classes have their methods stored in their respective <code>gtk::WidgetExt</code>, <code>gtk::ContainerExt</code>, and <code>gtk::BoxExt</code> traits. This will allow you to conveniently handle your widgets in a generic fashion. Maybe you have a function that can be perfectly written as <code>fn function&lt;W: WidgetExt&gt;(widget: &amp;W) {}</code>,</p>
<h2 id="gtk-is-not-thread-safe"><a class="header" href="#gtk-is-not-thread-safe">GTK is not thread-safe</a></h2>
<p>Finally, although GObjects can be thread-safe, GTK widgets are most definitely not. You should not attempt to send GTK widgets across thread boundaries, which thankfully the Rust type system will not permit. GTK widgets must be created and interacted with exclusively on the thread that GTK was initialized on.</p>
<p>There are crates such as <code>fragile</code> that would allow you to wrap your widgets into a <code>Fragile&lt;T&gt;</code> and send them across threads, but this is most certainly an anti-pattern. The way a <code>Fragile&lt;T&gt;</code> works is that it prevents you from accessing the <code>T</code> inside the wrapper unless you are unwrapping it from the same thread that it was created on. If you design your software correctly, you won't have to resort to this kind of arcane magic. Turn back before it is too late.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Before we begin, ensure that you have the necessary development files installed for GTK. On Debian platforms, you will need:</p>
<ul>
<li><code>libgtk-3-dev</code> for GTK3</li>
<li><code>libgtk-4-dev</code> for GTK4</li>
<li><code>libwebkit2gtk-4.0-dev</code> if embedding a GTK WebKit View</li>
<li><code>libgtksourceview-4-dev</code> if embedding a GTK Source View</li>
</ul>
<p>On the Rust side of things, you should install:</p>
<ul>
<li><code>cargo-edit</code> with <code>cargo install cargo-edit</code>, because that'll make adding dependencies to your project easier.</li>
<li><code>rust-analyzer</code> in your IDE so that you'll have instant feedback about warnings and errors as you type</li>
</ul>
<h2 id="creating-your-project"><a class="header" href="#creating-your-project">Creating Your Project</a></h2>
<p>Now we're going to start the process of actually building our first GTK application. Create your project, and add the following dependencies that we need to get started:</p>
<pre><code>cargo new first-gtk-app
cd first-gtk-app
cargo add gtk glib async-channel cascade
</code></pre>
<h3 id="initializing-gtk"><a class="header" href="#initializing-gtk">Initializing GTK</a></h3>
<p>Now we're ready to start with code. Lets start by setting your application's name, and initializing GTK.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate cascade;

use std::process;

fn main() {
    glib::set_program_name(&quot;First GTK App&quot;.into());
    glib::set_application_name(&quot;First GTK App&quot;);

    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Thread will block here until the application is quit
    gtk::main();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="event-driven-approach"><a class="header" href="#event-driven-approach">Event-Driven Approach</a></h1>
<p>In every GTK application that I write, I start by setting up an event handler for processing all of the events received from widgets in the application, as well as events received from background processes. Using this event-driven approach, you can eliminate the need for reference counters, or the need to share any data across widget signals.</p>
<p>In this model, all application state and widgets can be maintained in one central location of your application, or within compartmentalized regions that make sense for your application. Because each widget signal will only require to contain a <code>Sender</code> in order to send an <code>Event</code> to your event handler, which can then fetch whatever information it needs from any widget in its possession. Therefore, the event handler contains exclusive ownership over all widgets and application state.</p>
<h2 id="setting-it-up"><a class="header" href="#setting-it-up">Setting it up</a></h2>
<p>To achieve this, we need an async channel that we can get from the <code>async-channel</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (tx, rx) = async_channel::unbounded();
<span class="boring">}
</span></code></pre></pre>
<p>Now we need some event variants that our channel will emit:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event {
    Clicked
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we will attach the receiver to a future which merely loops on our receiver forever:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_handler = async move {
    while let Ok(event) = rx.recv().await {
        match event {
            Event::Clicked =&gt; {

            }
        }
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Your source code should now look like so, and you are now ready to continue to setting up a window with a clickable button.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate cascade;

use std::process;

enum Event {
    Clicked
}

fn main() {
    glib::set_program_name(&quot;First GTK App&quot;.into());
    glib::set_application_name(&quot;First GTK App&quot;);

    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Attach `tx` to our widgets, and `rx` to our event handler
    let (tx, rx) = async_channel::unbounded();

    // Processes all application events received from signals
    let event_handler = async move {
        while let Ok(event) = rx.recv().await {
            match event {
                Event::Clicked =&gt; {

                }
            }
        }
    };

    // GLib has an executor in the background that will
    // asynchronously handle our events on this thread
    glib::MainContext::default().spawn_local(event_handler);

    // Thread will block here until the application is quit
    gtk::main();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-window-with-a-button"><a class="header" href="#creating-a-window-with-a-button">Creating a Window with a Button</a></h1>
<h2 id="using-glib-as-an-async-runtime"><a class="header" href="#using-glib-as-an-async-runtime">Using GLib as an async runtime</a></h2>
<p>First, let's make ourselves a convenience function for blocking on a future:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

fn block_on&lt;F&gt;(future: F) -&gt; F::Output where F: Future {
    glib::MainContext::default().block_on(future)
}
<span class="boring">}
</span></code></pre></pre>
<p>This will schedule our futures to execute on the main thread, alongside all of the futures scheduled by GTK itself. Using <code>glib::MainContext::get_thread_default()</code> will get an executor for the thread where you are calling this from. This can be useful if you're wanting to spawn a future on a background thread for running your background tasks. There is also an option of using <code>glib::ThreadPool</code>, which gives you a multi-threaded executor which defaults to the number of virtual CPU cores in the system, and by default parks threads that have been idle for more than 15 seconds.</p>
<h2 id="creating-the-app-struct"><a class="header" href="#creating-the-app-struct">Creating the App struct</a></h2>
<p>I typically have a single <code>App</code> struct where all application state and GTK widgets that are regularly interacted with are stored. We're going to start with a struct that contains a <code>gtk::Button</code> and a <code>u32</code> &quot;clicked&quot; variable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_channel::Sender;

struct App {
    pub button: gtk::Button,
    pub clicked: u32,
}

impl App {
    pub fn new(tx: Sender&lt;Event&gt;) -&gt; Self {}
}
<span class="boring">}
</span></code></pre></pre>
<p>When creating the application, we will take ownership of the <code>Sender</code> that we created earlier, and pass this into every <code>connect_signal()</code> method that is called on a widget. The <code>connect_signal()</code> methods will create a future on the main context that idles until the condition for that future has been emitted. A <code>gtk::Button</code>, for example, has a <code>connect_clicked()</code> method which will have its callbacks invoked when <code>clicked</code> is emitted — which happens on a click of the button.</p>
<p>Note that you may connect multiple callbacks onto the same signal. If you wish to remove one, you should be careful to store the <code>SignalHandlerId</code> that is returned from the <code>connect_signal()</code> method. Then call <code>widget.disconnect(id)</code> to remove the signal registered to that widget. If you only wish to temporarily block a signal, you can call <code>widget.block_signal(id)</code> and <code>widget.unblock_signal(id)</code> respectively.</p>
<h2 id="creating-widgets-for-our-app"><a class="header" href="#creating-widgets-for-our-app">Creating widgets for our app</a></h2>
<p>First, we will create the button that we will have the user click. The button will have a label which reads, &quot;Click Me&quot;. The border will be set to 4 so that the button isn't hugging the edges of the container it is attached to. And then will program it to send an event when it is clicked.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = cascade! {
    gtk::Button::with_label(&quot;Click Me&quot;);
    ..set_border_width(4);
    ..connect_clicked(move |_| {
        let _ = block_on(tx.send(Event::Clicked));
    });
};
<span class="boring">}
</span></code></pre></pre>
<p>Note that since we are using an async channel, the sender has to be awaited when it is sending a value. We can use GLib's default executor to await our send.</p>
<p>Next is creating a container widget to hold our button. This container will also invoke <code>show_all()</code> to make the container visible, and all of the widgets inside the container.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = cascade! {
    gtk::Box::new(gtk::Orientation::Vertical, 0);
    ..add(&amp;button);
    ..show_all();
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="creating-the-window"><a class="header" href="#creating-the-window">Creating the window</a></h2>
<p>Next we we will create the <code>Toplevel</code> window for this application, and attach our container to the window. We will set a title, connect the event to be called when window is deleted, and also set the default icon for our application. The <code>Toplevel</code> window is the main window of your application. A window can only have one widget attached to it, which we will assign with the <code>add()</code> method. The <code>set_title()</code> method will set the title of your application. The <code>connect_delete_event</code> method is invoked whenever the window is destroyed, and we will program this to call <code>gtk::main_quit()</code> to stop the mainloop, thereby having <code>gtk::main()</code> return, which has our application quit.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _window = cascade! {
    gtk::Window::new(gtk::WindowType::Toplevel);
    ..add(&amp;container);
    ..set_title(&quot;First GTK App&quot;);
    ..connect_delete_event(move |_, _| {
        gtk::main_quit();
        gtk::Inhibit(false)
    });
    ..show_all();
};
<span class="boring">}
</span></code></pre></pre>
<p>One last thing that should be done for window managers is to set a default icon for the application:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gtk::Window::set_default_icon_name(&quot;icon-name-here&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can finally return our <code>App</code> struct, which should look like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl App {
    pub fn new(tx: Sender&lt;Event&gt;) -&gt; Self {
        let button = cascade! {
            gtk::Button::with_label(&quot;Click Me&quot;);
            ..set_border_width(4);
            ..connect_clicked(move |_| {
                let _ = block_on(tx.send(Event::Clicked));
            });
        };

        let container = cascade! {
            gtk::Box::new(gtk::Orientation::Vertical, 0);
            ..add(&amp;button);
            ..show_all();
        };

        let _window = cascade! {
            gtk::Window::new(gtk::WindowType::Toplevel);
            ..set_title(&quot;First GTK App&quot;);
            ..add(&amp;container);
            ..connect_delete_event(move |_, _| {
                gtk::main_quit();
                gtk::Inhibit(false)
            });
            ..show_all();
        };

        gtk::Window::set_default_icon_name(&quot;icon-name-here&quot;);

        Self { button, clicked: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="responding-to-the-clicked-event"><a class="header" href="#responding-to-the-clicked-event">Responding to the clicked event</a></h2>
<p>In the example below, you can see that we have passed ownership of the <code>App</code> into the event handler. The <code>clicked</code> property is incremented whenever we receive <code>Event::Clicked</code>. The button's label is updated to show how many times it has been clicked.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    glib::set_program_name(&quot;First GTK App&quot;.into());
    glib::set_application_name(&quot;First GTK App&quot;);

    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Attach `tx` to our widgets, and `rx` to our event handler
    let (tx, rx) = async_channel::unbounded();

    let mut app = App::new(tx);

    // Processes all application events received from signals
    let event_handler = async move {
        while let Ok(event) = rx.recv().await {
            match event {
                Event::Clicked =&gt; {
                    app.clicked += 1;
                    app.button.set_label(&amp;format!(&quot;I have been clicked {} times&quot;, app.clicked));
                }
            }
        }
    };

    // GLib has an executor in the background that will
    // asynchronously handle our events on this thread
    glib::MainContext::default().spawn_local(event_handler);

    // Thread will block here until the application is quit
    gtk::main();
}
</code></pre></pre>
<p>You may run the application with <code>cargo run</code> and try it out.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
